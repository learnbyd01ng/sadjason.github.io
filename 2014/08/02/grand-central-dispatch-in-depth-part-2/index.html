
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>GCD深入理解（2） | 张不坏的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="张不坏">
    
    <meta name="description" content="写在前面

本文原文为raywenderlich的《grand-central-dispatch-in-depth-part-1》；顺便提及一下，笔者认为，对于iOS初学者而言，raywenderlich是一个极佳的学习站点。
本文为转载内容，转自《GCD深入理解（二）》，GCD深入理解（一）和GC">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/Tinny.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/Tinny.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="张不坏的博客" title="张不坏的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="张不坏的博客">张不坏的博客</a></h1>
				<h2 class="blog-motto">Valar Morghulis</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
                    <ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
					</li>
                <li><div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div></li>

				</ul>
			</nav>	
</div>

    </header>
    <div id="container" class="clearfix">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/02/grand-central-dispatch-in-depth-part-2/" title="GCD深入理解（2）" itemprop="url">GCD深入理解（2）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://sadjason.github.io" title="张不坏">张不坏</a>
    </p>
  <p class="article-time">
    <time datetime="2014-08-02T03:22:52.000Z" itemprop="datePublished">2014-08-02</time>
    更新日期:<time datetime="2015-07-04T09:18:19.000Z" itemprop="dateModified">2015-07-04</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#纠正过早弹出的提示"><span class="toc-number">1.</span> <span class="toc-text">纠正过早弹出的提示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调度组（Dispatch_Group）解决问题方式一"><span class="toc-number">1.1.</span> <span class="toc-text">调度组（Dispatch Group）解决问题方式一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度组（Dispatch_Group）解决问题方式二"><span class="toc-number">1.2.</span> <span class="toc-text">调度组（Dispatch Group）解决问题方式二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch_apply介绍_—_太多并发带来的风险"><span class="toc-number">1.3.</span> <span class="toc-text">dispatch_apply介绍 — 太多并发带来的风险</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD的其他趣味"><span class="toc-number">2.</span> <span class="toc-text">GCD的其他趣味</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞——正确的方式"><span class="toc-number">2.1.</span> <span class="toc-text">阻塞——正确的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-number">2.2.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Dispatch_Source"><span class="toc-number">2.3.</span> <span class="toc-text">使用Dispatch Source</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#之后又该往何处去？"><span class="toc-number">3.</span> <span class="toc-text">之后又该往何处去？</span></a></li></ol>
		</div>
		
		<p><strong>写在前面</strong></p>
<ol>
<li>本文原文为raywenderlich的《<a href="http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="external">grand-central-dispatch-in-depth-part-1</a>》；顺便提及一下，笔者认为，对于iOS初学者而言，raywenderlich是一个极佳的学习站点。</li>
<li>本文为转载内容，转自《<a href="http://www.cocoachina.com/applenews/devnews/2014/0515/8433.html" target="_blank" rel="external">GCD深入理解（二）</a>》，GCD深入理解（一）和GCD深入理解（二）出自<a href="http://weibo.com/2076580237/B0tjrEQr9" target="_blank" rel="external">@nixzhu</a>，本文中出现的“译者”即<a href="(http://weibo.com/2076580237/B0tjrEQr9">@nixzhu</a>)；</li>
<li>笔者在学习<a href="http://weibo.com/2076580237/B0tjrEQr9" target="_blank" rel="external">@nixzhu</a>的这两篇博文过程中作了一些笔记，近期又正好学习使用markdown来写博客，于是有将这两篇文章搬到自己的博客遂成此文。 </li>
</ol>
<p>欢迎来到GCD深入理解系列教程的第二部分（也是最后一部分）。</p>
<p>在本系列的<a href="http://zhangbuhuai.com/2014/08/01/grand-central-dispatch-in-depth-part-1/" target="_blank" rel="external">第一部分</a>中，你已经学到超过你想像的关于并发、线程以及GCD如何工作的知识。通过在初始化时利用dispatch_once，你创建了一个线程安全的PhotoManager单例，而且你通过使用<code>dispatch_barrier_async</code>和<code>dispatch_sync</code>的组合使得对Photos数组的读取和写入都变得线程安全了。</p>
<p>除了上面这些，你还通过利用<code>dispatch_after</code>来延迟显示提示信息，以及利用<code>dispatch_async</code>将CPU密集型任务从ViewController的初始化过程中剥离出来异步执行，达到了增强应用的用户体验的目的。</p>
<p>如果你一直跟着第一部分的教程在写代码，那你可以继续你的工程。但如果你没有完成第一部分的工作，或者不想重用你的工程，你可以<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_End_1.zip" target="_blank" rel="external">下载</a>第一部分最终的代码。</p>
<p>那就让我们来更深入地探索<code>GCD</code>吧！</p>
<h2 id="纠正过早弹出的提示">纠正过早弹出的提示</h2>
<p>你可能已经注意到当你尝试用Le Internet选项来添加图片时，一个UIAlertView会在图片下载完成之前就弹出，如下如所示： </p>
<p><img src="/img/201408/dowloadearly.png" alt="dowloadearly.png"></p>
<p>问题的症结在PhotoManagers的downloadPhotoWithCompletionBlock:里，它目前的实现如下：</p>
<figure class="highlight Objective-C"><pre><div class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</div><div class="line">{</div><div class="line">    __block <span class="built_in">NSError</span> *error;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</div><div class="line">        <span class="built_in">NSURL</span> *url;</div><div class="line">        <span class="keyword">switch</span> (i) {</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        </div><div class="line">        Photo *photo = [[Photo alloc] initwithURL:url</div><div class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) {</div><div class="line">                                  <span class="keyword">if</span> (_error) {</div><div class="line">                                      error = _error;</div><div class="line">                                  }</div><div class="line">                              }];</div><div class="line">        </div><div class="line">        [[PhotoManager sharedManager] addPhoto:photo];</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (completionBlock) {</div><div class="line">        completionBlock(error);</div><div class="line">    }</div><div class="line">}</div></pre></figure>

<p>在方法的最后调用了completionBlock，因为此时你假设所有的照片都已下载完成。但很不幸，此时并不能保证所有的下载都已完成。</p>
<p>Photo类的实例方法用某个URL开始下载某个文件并立即返回，但此时下载并未完成。换句话说，当downloadPhotoWithCompletionBlock:在其末尾调用completionBlock时，它就假设了它自己所使用的方法全都是同步的，而且每个方法都完成了它们的工作。</p>
<p>然而，-[Photo initWithURL:withCompletionBlock:]是异步执行的，会立即返回——所以这种方式行不通。</p>
<p>因此，只有在所有的图像下载任务都调用了它们自己的Completion Block之后，downloadPhotoWithCompletionBlock:才能调用它自己的completionBlock。问题是：你该如何监控并发的异步事件？你不知道它们何时完成，而且它们完成的顺序完全是不确定的。</p>
<p>或许你可以写一些比较Hacky的代码，用多个布尔值来记录每个下载的完成情况，但这样做就缺失了扩展性，而且说实话，代码会很难看。</p>
<p>幸运的是， 解决这种对多个异步任务的完成进行监控的问题，恰好就是设计<code>dispatch_group</code>的目的。</p>
<h3 id="调度组（Dispatch_Group）解决问题方式一">调度组（Dispatch Group）解决问题方式一</h3>
<p><code>Dispatch Group</code>会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，<code>Dispatch Group</code>可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个dispatch_group_t的实例来记下这些不同的任务。</p>
<p>当组中所有的事件都完成时，<strong>GCD的API提供了两种通知方式</strong>。</p>
<p>第一种是<code>dispatch_group_wait</code>，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的。</p>
<p>打开PhotoManager.m，用下列实现替换downloadPhotosWithCompletionBlock:</p>
<figure class="highlight Objective-C"><pre><div class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</div><div class="line">{</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^{ <span class="comment">// 1</span></div><div class="line">        </div><div class="line">        __block <span class="built_in">NSError</span> *error;</div><div class="line">        dispatch_group_t downloadGroup = dispatch_group_create(); <span class="comment">// 2</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</div><div class="line">            <span class="built_in">NSURL</span> *url;</div><div class="line">            <span class="keyword">switch</span> (i) {</div><div class="line">                <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            </div><div class="line">            dispatch_group_enter(downloadGroup); <span class="comment">// 3</span></div><div class="line">            Photo *photo = [[Photo alloc] initwithURL:url</div><div class="line">                                  withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) {</div><div class="line">                                      <span class="keyword">if</span> (_error) {</div><div class="line">                                          error = _error;</div><div class="line">                                      }</div><div class="line">                                      dispatch_group_leave(downloadGroup); <span class="comment">// 4</span></div><div class="line">                                  }];</div><div class="line">            </div><div class="line">            [[PhotoManager sharedManager] addPhoto:photo];</div><div class="line">        }</div><div class="line">        dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); <span class="comment">// 5</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{ <span class="comment">// 6</span></div><div class="line">            <span class="keyword">if</span> (completionBlock) { <span class="comment">// 7</span></div><div class="line">                completionBlock(error);</div><div class="line">            }</div><div class="line">        });</div><div class="line">    });</div><div class="line">}</div></pre></figure>

<p>按照注释的顺序，你会看到：</p>
<ol>
<li>因为你在使用的是同步的dispatch_group_wait，它会阻塞当前线程，所以你要用dispatch_async将整个方法放入后台队列以避免阻塞主线程；</li>
<li>创建一个新的Dispatch Group，<strong>它的作用就像一个用于未完成任务的计数器</strong>；</li>
<li><code>dispatch_group_enter</code>手动通知Dispatch Group任务已经开始。你必须保证<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>成对出现，否则你可能会遇到诡异的崩溃问题；</li>
<li>手动通知Group它的工作已经完成。再次说明，你必须要确保进入Group的次数和离开Group的次数相等；</li>
<li>dispatch_group_wait会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值；你可以对此返回值做条件判断以确定是否超出等待周期；然而，你在这里用<code>DISPATCH_TIME_FOREVER</code>让它永远等待。它的意思，勿庸置疑就是，永－远－等－待！这样很好，因为图片的创建工作总是会完成的；</li>
<li>此时此刻，你已经确保了，要么所有的图片任务都已完成，要么发生了超时。然后，你在主线程上运行completionBlock回调。这会将工作放到主线程上，并在稍后执行；</li>
<li>最后，检查completionBlock是否为nil，如果不是，那就运行它；</li>
</ol>
<p>编译并运行你的应用，尝试下载多个图片，观察你的应用是在何时运行completionBlock的。<br>注意：如果你是在真机上运行应用，而且网络活动发生得太快以致难以观察completionBlock被调用的时刻，那么你可以在Settings应用里的开发者相关部分里打开一些网络设置，以确保代码按照我们所期望的那样工作。只需去往Network Link Conditioner区，开启它，再选择一个Profile，“Very Bad Network”就不错。</p>
<p>如果你是在模拟器里运行应用，你可以使用来自<a href="http://nshipster.com/network-link-conditioner/" target="_blank" rel="external">GitHub的Network Link Conditioner</a>来改变网络速度。它会成为你工具箱中的一个好工具，因为它强制你研究你的应用在连接速度并非最佳的情况下会变成什么样。</p>
<p>目前为止的解决方案还不错，但是总体来说，如果可能，最好还是要避免阻塞线程。你的下一个任务是重写一些方法，以便当所有下载任务完成时能异步通知你。</p>
<p>在我们转向另外一种使用Dispatch Group的方式之前，先看一个简要的概述，关于何时以及怎样使用有着不同的队列类型的Dispatch Group ：</p>
<ol>
<li>自定义串行队列：它很适合当一组任务完成时发出通知；</li>
<li>主队列（串行）：它也很适合这样的情况。但如果你要同步地等待所有工作地完成，那你就不应该使用它，因为你不能阻塞主线程。然而，异步模型是一个很有吸引力的能用于在几个较长任务（例如网络调用）完成后更新UI的方式；</li>
<li>并发队列：它也很适合Dispatch Group和完成时通知。</li>
</ol>
<h3 id="调度组（Dispatch_Group）解决问题方式二">调度组（Dispatch Group）解决问题方式二</h3>
<p>上面的一切都很好，但在另一个队列上异步调度然后使用dispatch_group_wait来阻塞实在显得有些笨拙。是的，还有另一种方式……</p>
<p>在PhotoManager.m中找到downloadPhotosWithCompletionBlock:方法，用下面的实现替换它：</p>
<figure class="highlight Objective-C"><pre><div class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</div><div class="line">{</div><div class="line">    <span class="comment">// 1</span></div><div class="line">    __block <span class="built_in">NSError</span> *error;</div><div class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</div><div class="line">        <span class="built_in">NSURL</span> *url;</div><div class="line">        <span class="keyword">switch</span> (i) {</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        </div><div class="line">        dispatch_group_enter(downloadGroup); <span class="comment">// 2</span></div><div class="line">        Photo *photo = [[Photo alloc] initwithURL:url</div><div class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) {</div><div class="line">                                  <span class="keyword">if</span> (_error) {</div><div class="line">                                      error = _error;</div><div class="line">                                  }</div><div class="line">                                  dispatch_group_leave(downloadGroup); <span class="comment">// 3</span></div><div class="line">                              }];</div><div class="line">        </div><div class="line">        [[PhotoManager sharedManager] addPhoto:photo];</div><div class="line">    }</div><div class="line">    </div><div class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ <span class="comment">// 4</span></div><div class="line">        <span class="keyword">if</span> (completionBlock) {</div><div class="line">            completionBlock(error);</div><div class="line">        }</div><div class="line">    });</div><div class="line">}</div></pre></figure>

<p>下面解释新的异步方法如何工作：</p>
<ol>
<li>在新的实现里，因为你没有阻塞主线程，所以你并不需要将方法包裹在async调用中；</li>
<li>同样的enter方法，没做任何修改；</li>
<li>同样的leave方法，也没做任何修改；</li>
<li><code>dispatch_group_notify</code>以异步的方式工作。当Dispatch Group中没有任何任务时，它就会执行其代码，那么completionBlock便会运行。你还指定了运行completionBlock的队列，此处，主队列就是你所需要的。</li>
</ol>
<p>笔者注：注意dispatch_group_notify中的第二个参数“dispatch_get_main_queue()”指定了调度completionBlock的队列，而不是指定调度dispatch_group_notify任务的队列哦！</p>
<p>对于这个特定的工作，上面的处理明显更清晰，而且也不会阻塞任何线程。</p>
<h3 id="dispatch_apply介绍_—_太多并发带来的风险">dispatch_apply介绍 — 太多并发带来的风险</h3>
<p>既然你的工具箱里有了这些新工具，你大概做任何事情都想使用它们，对吧？ </p>
<p><img src="/img/201408/allInOne.jpg" alt="allInOne.jpg"></p>
<p>看看PhotoManager中的downloadPhotosWithCompletionBlock方法。你可能已经注意到这里的for循环，它迭代三次，下载三个不同的图片。你的任务是尝试让for循环并发运行，以提高其速度。</p>
<p><code>dispatch_apply</code>刚好可用于这个任务。</p>
<p>dispatch_apply表现得就像一个for循环，但它能并发地执行不同的迭代。<strong>dispatch_apply这个函数是同步的</strong>，所以和普通的for循环一样，它只会在所有工作都完成后才会返回。</p>
<p>当在Block内计算任何给定数量的工作的最佳迭代数量时，必须要小心，因为过多的迭代和每个迭代只有少量的工作会导致大量开销以致它能抵消任何因并发带来的收益。而被称为<code>跨越式</code>（striding）的技术可以在此帮到你，即通过在每个迭代里多做几个不同的工作。</p>
<p> 译者注：大概就能减少并发数量吧，作者是提醒大家注意并发的开销，记在心里！</p>
<p>那何时才适合用<code>dispatch_apply</code>呢？</p>
<ol>
<li>自定义串行队列：串行队列会完全抵消dispatch_apply的功能；你还不如直接使用普通的for循环；</li>
<li>主队列（串行）：与上面一样，在串行队列上不适合使用dispatch_apply；还是用普通的for循环吧；</li>
<li>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</li>
</ol>
<p>回到 downloadPhotosWithCompletionBlock: 并用下列实现替换它：</p>
<figure class="highlight Objective-C"><pre><div class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</div><div class="line">{</div><div class="line">    __block <span class="built_in">NSError</span> *error;</div><div class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</div><div class="line">    </div><div class="line">    dispatch_apply(<span class="number">3</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^(size_t i) {</div><div class="line">        </div><div class="line">        <span class="built_in">NSURL</span> *url;</div><div class="line">        <span class="keyword">switch</span> (i) {</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        </div><div class="line">        dispatch_group_enter(downloadGroup);</div><div class="line">        Photo *photo = [[Photo alloc] initwithURL:url</div><div class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) {</div><div class="line">                                  <span class="keyword">if</span> (_error) {</div><div class="line">                                      error = _error;</div><div class="line">                                  }</div><div class="line">                                  dispatch_group_leave(downloadGroup);</div><div class="line">                              }];</div><div class="line">        </div><div class="line">        [[PhotoManager sharedManager] addPhoto:photo];</div><div class="line">    });</div><div class="line">    </div><div class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{</div><div class="line">        <span class="keyword">if</span> (completionBlock) {</div><div class="line">            completionBlock(error);</div><div class="line">        }</div><div class="line">    });</div><div class="line">}</div></pre></figure>

<p>你的循环现在是并行运行的了；在上面的代码中，在调用dispatch_apply时，第一个参数指明了迭代的次数，用第二个参数指定了任务运行的队列，而第三个参数是一个Block。</p>
<p>要知道虽然你有代码保证添加相片时线程安全，但图片的顺序却可能不同，这取决于线程完成的顺序。</p>
<p>编译并运行，然后从“Le Internet”添加一些照片。注意到区别了吗？</p>
<p>在真机上运行新代码会稍微更快的得到结果。但我们所做的这些提速工作真的值得吗？</p>
<p>实际上，在这个例子里并不值得。原因如下：</p>
<ol>
<li>你创建并行运行线程而付出的开销，很可能比直接使用for循环要多。若你要以合适的步长迭代非常大的集合，那才应该考虑使用dispatch_apply；</li>
<li>你用于创建应用的时间是有限的——除非实在太糟糕否则不要浪费时间去提前优化代码。如果你要优化什么，那去优化那些明显值得你付出时间的部分。你可以通过在Instruments里分析你的应用，找出最长运行时间的方法。看看<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" target="_blank" rel="external">如何在Xcode中使用Instruments</a>可以学到更多相关知识；</li>
<li>通常情况下，优化代码会让你的代码更加复杂，不利于你自己和其他开发者阅读。请确保添加的复杂性能换来足够多的好处。</li>
</ol>
<p>记住，不要在优化上太疯狂。你只会让你自己和后来者更难以读懂你的代码。</p>
<h2 id="GCD的其他趣味">GCD的其他趣味</h2>
<p>等一下！还有更多！有一些额外的函数在不同的道路上走得更远。虽然你不会太频繁地使用这些工具，但在对的情况下，它们可以提供极大的帮助。</p>
<h3 id="阻塞——正确的方式">阻塞——正确的方式</h3>
<p>这可能听起来像是个疯狂的想法，但你知道Xcode已有了测试功能吗？我知道，虽然有时候我喜欢假装它不存在，但在代码里构建复杂关系时编写和运行测试非常重要。</p>
<p>Xcode里的测试在<code>XCTestCase</code>的子类上执行，并运行任何方法签名以test开头的方法。测试在主线程运行，所以你可以假设所有测试都是串行发生的。</p>
<p>当一个给定的测试方法运行完成，<code>XCTest</code>方法将考虑此测试已结束，并进入下一个测试。这意味着任何来自前一个测试的异步代码会在下一个测试运行时继续运行。</p>
<p>网络代码通常是异步的，因此你不能在执行网络获取时阻塞主线程。也就是说，整个测试会在测试方法完成之后结束，这会让对网络代码的测试变得很困难。也就是，除非你在测试方法内部阻塞主线程直到网络代码完成。</p>
<p> 注意：有一些人会说，这种类型的测试不属于集成测试的首选集（Preferred Set）。一些人会赞同，一些人不会。但如果你想做，那就去做。</p>
<p><img src="/img/201408/youShallNotPass.png" alt="youShallNotPass.png"></p>
<p>导航到GooglyPuffTests.m并查看downloadImageURLWithString:，如下：</p>
<figure class="highlight Objective-C"><pre><div class="line">- (<span class="keyword">void</span>)downloadImageURLWithString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">{</div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</div><div class="line">    __block <span class="built_in">BOOL</span> isFinishedDownloading = <span class="literal">NO</span>;</div><div class="line">    __unused Photo *photo = [[Photo alloc]</div><div class="line">                             initwithURL:url</div><div class="line">                             withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) {</div><div class="line">                                 <span class="keyword">if</span> (error) {</div><div class="line">                                     XCTFail(<span class="string">@"%@ failed. %@"</span>, URLString, error);</div><div class="line">                                 }</div><div class="line">                                 isFinishedDownloading = <span class="literal">YES</span>;</div><div class="line">                             }];</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (!isFinishedDownloading) {}</div><div class="line">}</div></pre></figure>

<p>这是一种测试异步网络代码的幼稚方式。While循环在函数的最后一直等待，直到isFinishedDownloading布尔值变成True，它只会在Completion Block里发生。让我们看看这样做有什么影响。</p>
<p>通过在Xcode中点击Product/Test运行你的测试，如果你使用默认的键绑定，也可以使用快捷键<code>Cmd+U</code>来运行你的测试。</p>
<p>在测试运行时，注意Xcode debug导航栏里的CPU使用率。这个设计不当的实现就是一个基本的自旋锁。它很不实用，因为你在While循环里浪费了珍贵的CPU周期；而且它也几乎没有扩展性。</p>
<p>译者注：所谓自旋锁，就是某个线程一直抢占着CPU不断检查以等到它需要的情况出现。因为现代操作系统都是可以并发运行多个线程的，所以它所等待的那个线程也有机会被调度执行，这样它所需要的情况早晚会出现。</p>
<p>你可能需要使用前面提到的Network Link Conditioner，已便清楚地看到这个问题。如果你的网络太快，那么自旋只会在很短的时间里发生，难以观察。</p>
<p>译者注：作者反复提到网速太快，而我们还需要对付GFW，简直泪流满面！</p>
<p>你需要一个更优雅、可扩展的解决方案来阻塞线程直到资源可用。欢迎来到信号量。</p>
<h3 id="信号量">信号量</h3>
<p>信号量是一种老式的线程概念，由非常谦卑的Edsger W. Dijkstra介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。</p>
<p>如果你想学到更多关于信号量的知识，看看这个链接它<a href="http://greenteapress.com/semaphores/" target="_blank" rel="external">更细致地讨论了信号量理论</a>。如果你是学术型，那可以看一个软件开发中经典的<a href="http://greenteapress.com/semaphores/" target="_blank" rel="external">哲学家进餐问题</a>，它需要使用信号量来解决。</p>
<p>信号量让你控制多个消费者对有限数量资源的访问。举例来说，如果你创建了一个有着两个资源的信号量，那同时最多只能有两个线程可以访问临界区。其他想使用资源的线程必须在一个…你猜到了吗？…FIFO队列里等待。</p>
<p>让我们来使用信号量吧！</p>
<p>打开GooglyPuffTests.m并用下列实现替换downloadImageURLWithString:</p>
<figure class="highlight Objective-C"><pre><div class="line">- (<span class="keyword">void</span>)downloadImageURLWithString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">{</div><div class="line">    <span class="comment">// 1</span></div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</div><div class="line">    __unused Photo *photo = [[Photo alloc]</div><div class="line">                             initwithURL:url</div><div class="line">                             withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) {</div><div class="line">                                 <span class="keyword">if</span> (error) {</div><div class="line">                                     XCTFail(<span class="string">@"%@ failed. %@"</span>, URLString, error);</div><div class="line">                                 }</div><div class="line">                                 </div><div class="line">                                 <span class="comment">// 2</span></div><div class="line">                                 dispatch_semaphore_signal(semaphore);</div><div class="line">                             }];</div><div class="line">    </div><div class="line">    <span class="comment">// 3</span></div><div class="line">    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);</div><div class="line">    <span class="keyword">if</span> (dispatch_semaphore_wait(semaphore, timeoutTime)) {</div><div class="line">        XCTFail(<span class="string">@"%@ timed out"</span>, URLString);</div><div class="line">    } </div><div class="line">}</div></pre></figure>

<p>下面来说明你代码中的信号量是如何工作的：</p>
<ol>
<li>创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量；</li>
<li>在Completion Block里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程；</li>
<li>这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过10秒钟就会返回——一个平衡点！</li>
</ol>
<p>再次运行测试。只要你有一个正常工作的网络连接，这个测试就会马上成功。请特别注意CPU的使用率，与之前使用自旋锁的实现作个对比。</p>
<p>关闭你的网络链接再运行测试；如果你在真机上运行，就打开飞行模式。如果你的在模拟器里运行，你可以直接断开Mac的网络链接。测试会在10秒后失败。这很棒，它真的能按照预想的那样工作！</p>
<p>还有一些琐碎的测试，但如果你与一个服务器组协同工作，那么这些基本的测试能够防止其他人就最新的网络问题对你说三道四。</p>
<h3 id="使用Dispatch_Source">使用Dispatch Source</h3>
<p>GCD的一个特别有趣的特性是Dispatch Source，它基本上就是一个低级函数的grab-bag，能帮助你去响应或监测Unix信号、文件描述符、Mach端口、VFS节点，以及其它晦涩的东西。所有这些都超出了本教程讨论的范围，但你可以通过实现一个Dispatch Source对象并以一个相当奇特的方式来使用它来品尝那些晦涩的东西。</p>
<p>第一次使用Dispatch Source可能会迷失在如何使用一个源，所以你需要知晓的第一件事是dispatch_source_create如何工作。下面是创建一个源的函数原型：</p>
<figure class="highlight Objective-C"><pre><div class="line">dispatch_<span class="built_in">source</span>_t dispatch_<span class="built_in">source</span>_create(</div><div class="line">                                         dispatch_<span class="built_in">source</span>_<span class="built_in">type</span>_t <span class="built_in">type</span>,</div><div class="line">                                         uintptr_t handle,</div><div class="line">                                         unsigned long mask, </div><div class="line">                                         dispatch_queue_t queue);</div></pre></figure>

<p>第一个参数是dispatch_source_type_t。这是最重要的参数，因为它决定了handle和mask参数将会是什么。你可以查看<a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/constant_group/Dispatch_Source_Type_Constants" target="_blank" rel="external">Xcode 文档</a>得到哪些选项可用于每个dispatch_source_type_t参数。</p>
<p>下面你将监控DISPATCH_SOURCE_TYPE_SIGNAL。如<a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/c/macro/DISPATCH_SOURCE_TYPE_SIGNAL%22" target="_blank" rel="external">文档</a>所显示的：</p>
<blockquote>
<p>一个监控当前进程信号的Dispatch Source。handle是信号编号，mask未使用（传0即可）。</p>
</blockquote>
<p>这些Unix信号组成的列表可在头文件<a href="http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/signal.h" target="_blank" rel="external">signal.h</a>中找到。在其顶部有一堆#define语句。你将监控此信号列表中的SIGSTOP信号。这个信号将会在进程接收到一个无法回避的暂停指令时被发出。在你用LLDB调试器调试应用时你使用的也是这个信号。</p>
<p>去往PhotoCollectionViewController.m并添加如下代码到viewDidLoad的顶部，就在[super viewDidLoad]下面：</p>
<figure class="highlight Objective-C"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">  [<span class="keyword">super</span> viewDidLoad];</div><div class="line"> </div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="preprocessor">#if DEBUG</span></div><div class="line">      <span class="comment">// 2</span></div><div class="line">      <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div><div class="line"> </div><div class="line">       <span class="comment">// 3</span></div><div class="line">       <span class="keyword">static</span> dispatch_source_t source = <span class="literal">nil</span>;</div><div class="line"> </div><div class="line">       <span class="comment">// 4</span></div><div class="line">       __<span class="keyword">typeof</span>(<span class="keyword">self</span>) __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</div><div class="line"> </div><div class="line">       <span class="comment">// 5</span></div><div class="line">       <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">       <span class="built_in">dispatch_once</span>(&onceToken, ^{</div><div class="line">           <span class="comment">// 6</span></div><div class="line">           source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, <span class="number">0</span>, queue);</div><div class="line"> </div><div class="line">          <span class="comment">// 7</span></div><div class="line">          <span class="keyword">if</span> (source)</div><div class="line">          {</div><div class="line">              <span class="comment">// 8</span></div><div class="line">              dispatch_source_set_event_handler(source, ^{</div><div class="line">                  <span class="comment">// 9</span></div><div class="line">                  <span class="built_in">NSLog</span>(<span class="string">@"Hi, I am: %@"</span>, weakSelf);</div><div class="line">              });</div><div class="line">              dispatch_resume(source); <span class="comment">// 10</span></div><div class="line">          }</div><div class="line">      });</div><div class="line">  <span class="preprocessor">#endif</span></div><div class="line"> </div><div class="line">  <span class="comment">// The other stuff</span></div><div class="line">}</div></pre></figure>

<ol>
<li>最好是在DEBUG模式下编译这些代码，因为这会给“有关方面（Interested Parties）”很多关于你应用的洞察；</li>
<li>Just to mix things up，你创建了一个dispatch_queue_t实例变量而不是在参数上直接使用函数。当代码变长，分拆有助于可读性；</li>
<li>你需要source在方法范围之外也可被访问，所以你使用了一个static变量；</li>
<li>使用weakSelf以确保不会出现保留环（Retain Cycle）。这对PhotoCollectionViewController来说不是完全必要的，因为它会在应用的整个生命期里保持活跃。然而，如果你有任何其它会消失的类，这就能确保不会出现保留环而造成内存泄漏；</li>
<li>使用dispatch_once确保只会执行一次Dispatch Source的设置；</li>
<li>初始化source变量。你指明了你对信号监控感兴趣并提供了SIGSTOP信号作为第二个参数。进一步，你使用主队列处理接收到的事件——很快你就好发现为何要这样做；</li>
<li>如果你提供的参数不合格，那么Dispatch Source对象不会被创建。也就是说，在你开始在其上工作之前，你需要确保已有了一个有效的Dispatch Source；</li>
<li>当你收到你所监控的信号时，dispatch_source_set_event_handler就会执行。之后你可以在其Block里设置合适的逻辑处理器（Logic Handler）；</li>
<li>一个基本的NSLog语句，它将对象打印到控制台；</li>
<li>默认的，所有源都初始为暂停状态。如果你要开始监控事件，你必须告诉源对象恢复活跃状态。</li>
</ol>
<p>编译并运行应用；在调试器里暂停并立即恢复应用，查看控制台，你会看到这个来自黑暗艺术的函数确实可以工作。你看到的大概如下：</p>
<p><img src="/img/201408/cdfsresult.png" alt="cdfsresult.png"></p>
<p>你的应用现在具有调试感知了！这真是超级棒，但在真实世界里该如何使用它呢？</p>
<p>你可以用它去调试一个对象并在任何你想恢复应用的时候显示数据；你同样能给你的应用加上自定义的安全逻辑以便在恶意攻击者将一个调试器连接到你的应用上时保护它自己（或用户的数据）。</p>
<p>译者注：好像挺有用！</p>
<p>一个有趣的主意是，使用此方式的作为一个堆栈追踪工具去找到你想在调试器里操纵的对象。 </p>
<p><img src="/img/201408/jackChen.png" alt="jackChen.png"></p>
<p>稍微想想这个情况。当你意外地停止调试器，你几乎从来都不会在所需的栈帧上。现在你可以在任何时候停止调试器并在你所需的地方执行代码。如果你想在你的应用的某一点执行的代码非常难以从调试器访问的话，这会非常有用。有机会试试吧！ </p>
<p><img src="/img/201408/wangnima.png" alt="wangnima.png"></p>
<p>将一个断点放在你刚添加在viewDidLoad里的事件处理器的NSLog语句上。在调试器里暂停，然后再次开始；应用会到达你添加的断点。现在你深入到你的PhotoCollectionViewController方法深处。你可以访问PhotoCollectionViewController的实例得到你关心的内容。非常方便！</p>
<p>注意：如果你还没有注意到在调试器里的是哪个线程，那现在就看看它们。主线程总是第一个被libdispatch跟随，它是GCD的坐标，作为第二个线程。之后，线程计数和剩余线程取决于硬件在应用到达断点时正在做的事情。</p>
<p>在调试器里，键入命令：</p>
<figure class="highlight Objective-C"><pre><div class="line"><span class="keyword">po</span> [[weakSelf navigationItem] setPromp<span class="variable">t:</span>@<span class="string">"WOOT!"</span>]</div></pre></figure>

<p>然后恢复应用的执行。你会看到如下内容：</p>
<p><img src="/img/201408/debugresult.png" alt="debugresult.png"></p>
<p><img src="/img/201408/wootPhotos.png" alt="wootPhotos.png.png"></p>
<p>使用这个方法，你可以更新UI、查询类的属性，甚至是执行方法——所有这一切都不需要重启应用并到达某个特定的工作状态。相当优美吧！</p>
<p> 译者注：发挥这一点，是可以做出一些调试库的吧？</p>
<h2 id="之后又该往何处去？">之后又该往何处去？</h2>
<p>你可以在此下载最终的<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff-Final.zip" target="_blank" rel="external">项目</a>。</p>
<p>我讨厌再次提及此主题，但你真的要看看<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" target="_blank" rel="external">如何使用Instruments</a>教程。如果你计划优化你的应用，那你一定要学会使用它。请注意Instruments擅长于分析相对执行：比较哪些区域的代码相对于其它区域的代码花费了更长的时间。如果你尝试计算出某个方法实际的执行时间，那你可能需要拿出更多的自酿的解决方案（Home-brewed Solution）。</p>
<p>同样请看看<a href="http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues" target="_blank" rel="external">如何使用NSOperations和NSOperationQueues</a>吧，它们是建立在GCD之上的并发技术。大体来说，如果你在写简单的用过就忘的任务，那它们就是使用GCD的最佳实践，NSOperations提供更好的控制、处理大量并发操作的实现，以及一个以速度为代价的更加面向对象的范例。</p>
<p>记住，除非你有特别的原因要往下流走（译者的玩笑：即使用低级别API），否则永远应尝试并坚持使用高级的API。如果你想学到更多或想做某些非常非常“有趣”的事情，那你就应该冒险进入Apple的黑暗艺术。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/GCD/">GCD</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://sadjason.github.io/2014/08/02/grand-central-dispatch-in-depth-part-2/" data-title="GCD深入理解（2） | 张不坏的博客" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/08/03/AFNetworking-20-Tutorial/" title="AFNetworking 2.0教程">
  <strong>PREVIOUS:</strong><br/>
  <span>
  AFNetworking 2.0教程</span>
</a>
</div>


<div class="next">
<a href="/2014/08/01/grand-central-dispatch-in-depth-part-1/"  title="GCD深入理解（1）">
 <strong>NEXT:</strong><br/> 
 <span>GCD深入理解（1）
</span>
</a>
</div>

</nav>

		<!-- 多说评论框 start -->
	<!--<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>-->
	<div class="ds-thread" data-thread-key="2014/08/02/grand-central-dispatch-in-depth-part-2/" data-title="GCD深入理解（2）" data-url=""></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
		var duoshuoQuery = {short_name:"张不坏"};
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
	</script>
	<!-- 多说公共JS代码 end -->

</div>  
      
  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#纠正过早弹出的提示"><span class="toc-number">1.</span> <span class="toc-text">纠正过早弹出的提示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调度组（Dispatch_Group）解决问题方式一"><span class="toc-number">1.1.</span> <span class="toc-text">调度组（Dispatch Group）解决问题方式一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度组（Dispatch_Group）解决问题方式二"><span class="toc-number">1.2.</span> <span class="toc-text">调度组（Dispatch Group）解决问题方式二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch_apply介绍_—_太多并发带来的风险"><span class="toc-number">1.3.</span> <span class="toc-text">dispatch_apply介绍 — 太多并发带来的风险</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD的其他趣味"><span class="toc-number">2.</span> <span class="toc-text">GCD的其他趣味</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞——正确的方式"><span class="toc-number">2.1.</span> <span class="toc-text">阻塞——正确的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-number">2.2.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Dispatch_Source"><span class="toc-number">2.3.</span> <span class="toc-text">使用Dispatch Source</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#之后又该往何处去？"><span class="toc-number">3.</span> <span class="toc-text">之后又该往何处去？</span></a></li></ol>
  </div>

<div id="asidepart">
<div id="authorInfo">
	
		<div class="author-logo"></div>		
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
	</div>
</div>
<aside class="clearfix">


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>31</sup></a></li>
		
			<li><a href="/categories/Nodejs/" title="Node.js">Node.js<sup>1</sup></a></li>
		
			<li><a href="/categories/Objective-C/" title="Objective-C">Objective-C<sup>10</sup></a></li>
		
			<li><a href="/categories/Others/" title="Others">Others<sup>1</sup></a></li>
		
			<li><a href="/categories/Python/" title="Python">Python<sup>5</sup></a></li>
		
			<li><a href="/categories/Swift/" title="Swift">Swift<sup>17</sup></a></li>
		
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>61</sup></a></li>
		
		</ul>
</div>


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07">七月 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06">六月 2015</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05">五月 2015</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04">四月 2015</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03">三月 2015</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02">二月 2015</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01">一月 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08">八月 2014</a><span class="archive-list-count">8</span></li></ul>
  </div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/AFNetworking/" title="AFNetworking">AFNetworking<sup>5</sup></a></li>
		
			<li><a href="/tags/Array/" title="Array">Array<sup>7</sup></a></li>
		
			<li><a href="/tags/Assets/" title="Assets">Assets<sup>1</sup></a></li>
		
			<li><a href="/tags/Auto-Layout/" title="Auto Layout">Auto Layout<sup>1</sup></a></li>
		
			<li><a href="/tags/Backtracking/" title="Backtracking">Backtracking<sup>3</sup></a></li>
		
			<li><a href="/tags/Binary-Tree/" title="Binary Tree">Binary Tree<sup>2</sup></a></li>
		
			<li><a href="/tags/Block/" title="Block">Block<sup>1</sup></a></li>
		
			<li><a href="/tags/Debug/" title="Debug">Debug<sup>1</sup></a></li>
		
			<li><a href="/tags/Dynamic-Programming/" title="Dynamic Programming">Dynamic Programming<sup>8</sup></a></li>
		
			<li><a href="/tags/Edit-Distance/" title="Edit Distance">Edit Distance<sup>1</sup></a></li>
		
			<li><a href="/tags/GCD/" title="GCD">GCD<sup>8</sup></a></li>
		
			<li><a href="/tags/Greedy/" title="Greedy">Greedy<sup>1</sup></a></li>
		
			<li><a href="/tags/HTTP/" title="HTTP">HTTP<sup>1</sup></a></li>
		
			<li><a href="/tags/KMP/" title="KMP">KMP<sup>1</sup></a></li>
		
			<li><a href="/tags/KVO/" title="KVO">KVO<sup>1</sup></a></li>
		
			<li><a href="/tags/LeetCode/" title="LeetCode">LeetCode<sup>26</sup></a></li>
		
			<li><a href="/tags/Linked-List/" title="Linked List">Linked List<sup>1</sup></a></li>
		
			<li><a href="/tags/Mantle/" title="Mantle">Mantle<sup>1</sup></a></li>
		
			<li><a href="/tags/Masonry/" title="Masonry">Masonry<sup>1</sup></a></li>
		
			<li><a href="/tags/NSError/" title="NSError">NSError<sup>1</sup></a></li>
		
			<li><a href="/tags/NSOperation/" title="NSOperation">NSOperation<sup>1</sup></a></li>
		
			<li><a href="/tags/Nodejs/" title="Node.js">Node.js<sup>1</sup></a></li>
		
			<li><a href="/tags/Reachability/" title="Reachability">Reachability<sup>1</sup></a></li>
		
			<li><a href="/tags/RunLoop/" title="RunLoop">RunLoop<sup>1</sup></a></li>
		
			<li><a href="/tags/Runtime/" title="Runtime">Runtime<sup>5</sup></a></li>
		
			<li><a href="/tags/SVPullToRefresh/" title="SVPullToRefresh">SVPullToRefresh<sup>1</sup></a></li>
		
			<li><a href="/tags/Sort/" title="Sort">Sort<sup>9</sup></a></li>
		
			<li><a href="/tags/String/" title="String">String<sup>9</sup></a></li>
		
			<li><a href="/tags/Testing/" title="Testing">Testing<sup>1</sup></a></li>
		
			<li><a href="/tags/Tree/" title="Tree">Tree<sup>1</sup></a></li>
		
			<li><a href="/tags/Two-Pointers/" title="Two Pointers">Two Pointers<sup>1</sup></a></li>
		
			<li><a href="/tags/UIWebView/" title="UIWebView">UIWebView<sup>1</sup></a></li>
		
			<li><a href="/tags/WebViewJavascriptBridge/" title="WebViewJavascriptBridge">WebViewJavascriptBridge<sup>1</sup></a></li>
		
			<li><a href="/tags/Xcode/" title="Xcode">Xcode<sup>2</sup></a></li>
		
			<li><a href="/tags/ZBar/" title="ZBar">ZBar<sup>1</sup></a></li>
		
			<li><a href="/tags/iOS/" title="iOS">iOS<sup>6</sup></a></li>
		
			<li><a href="/tags/iPhone/" title="iPhone">iPhone<sup>1</sup></a></li>
		
			<li><a href="/tags/property/" title="property">property<sup>1</sup></a></li>
		
			<li><a href="/tags/socket-io/" title="socket-io">socket-io<sup>1</sup></a></li>
		
			<li><a href="/tags/多线程/" title="多线程">多线程<sup>2</sup></a></li>
		
			<li><a href="/tags/常用/" title="常用">常用<sup>9</sup></a></li>
		
		</ul>
</div>



</aside>
</div>
    </div>
    <footer><div id="footer" >

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  //back to top
  function backToTop(){
    var buttonHTML = $("<a href=\"#top\" id=\"back-top\">" + "<span>Back to Top</span></a>");
    buttonHTML.appendTo($("body"));
    var buttonToTop = $("#back-top");
    // hide #back-top first
    buttonToTop.hide();

    // fade in #back-top
    $(function() {
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                buttonToTop.fadeIn();
            } else {
                buttonToTop.fadeOut();
            }
        });
        // scroll body to 0px on click
        buttonToTop.click(function() {
            $('body,html').animate({
                scrollTop: 0
            }, 800);
            return false;
        });
    });
  }
  backToTop();

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      ta = $('#toc.toc-aside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });

  var show = true;
  c.click(function(){
    if(show == true){
        a.addClass('fadeOut').css('display', 'none');
        ta.css('display', 'block').addClass('fadeIn');
        m.addClass('moveMain');  
    }else{
        a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');     
        ta.css('display', 'none'); 
        m.removeClass('moveMain');
        $('#toc.toc-aside').css('display', 'none');
    }
    show = !show;
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{

    $(window).scroll(function(){
      ta.css("top",Math.max(140,240-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"null"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
