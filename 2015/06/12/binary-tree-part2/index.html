
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>二叉树与算法 第二弹 | 张不坏的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="张不坏">
    
    <meta name="description" content="写在前面
本文是《二叉树与算法第一弹》的续篇，之所以分为两篇来写，主要是因为篇幅太长。
《二叉树与算法第一弹》中主要分析了二叉树的3类算法问题：性质分析（譬如计算最高深度）、遍历问题、构建二叉树。本文将继续以LeetCode为参考，分析二叉树的其他算法问题。
反转二叉树
近期，我们猿族有意见比较吸引">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/Tinny.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/Tinny.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="张不坏的博客" title="张不坏的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="张不坏的博客">张不坏的博客</a></h1>
				<h2 class="blog-motto">Valar Morghulis</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
                    <ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
					</li>
                <li><div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div></li>

				</ul>
			</nav>	
</div>

    </header>
    <div id="container" class="clearfix">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/12/binary-tree-part2/" title="二叉树与算法 第二弹" itemprop="url">二叉树与算法 第二弹</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://sadjason.github.io" title="张不坏">张不坏</a>
    </p>
  <p class="article-time">
    <time datetime="2015-06-12T04:11:43.000Z" itemprop="datePublished">2015-06-12</time>
    更新日期:<time datetime="2015-07-04T09:24:04.000Z" itemprop="dateModified">2015-07-04</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反转二叉树"><span class="toc-number">2.</span> <span class="toc-text">反转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树和其他数据结构"><span class="toc-number">3.</span> <span class="toc-text">二叉树和其他数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#已排序数组转平衡二叉搜索树"><span class="toc-number">3.1.</span> <span class="toc-text">已排序数组转平衡二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#已排序链表转平衡二叉搜索树"><span class="toc-number">3.2.</span> <span class="toc-text">已排序链表转平衡二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将平衡二叉树撸成链表"><span class="toc-number">3.3.</span> <span class="toc-text">将平衡二叉树撸成链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树遍历衍生题"><span class="toc-number">4.</span> <span class="toc-text">二叉树遍历衍生题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Z字型遍历"><span class="toc-number">4.1.</span> <span class="toc-text">Z字型遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sum_Root_to_Leaf_Numbers"><span class="toc-number">4.2.</span> <span class="toc-text">Sum Root to Leaf Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Populating_Next_Right_Pointers_in_Each_Node"><span class="toc-number">4.3.</span> <span class="toc-text">Populating Next Right Pointers in Each Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary_Tree_Right_Side_View"><span class="toc-number">4.4.</span> <span class="toc-text">Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路径问题"><span class="toc-number">4.5.</span> <span class="toc-text">路径问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他问题"><span class="toc-number">5.</span> <span class="toc-text">其他问题</span></a></li></ol>
		</div>
		
		<h2 id="写在前面"><strong>写在前面</strong></h2>
<p>本文是《<a href="/2015/06/10/binary-tree-part1/">二叉树与算法第一弹</a>》的续篇，之所以分为两篇来写，主要是因为篇幅太长。</p>
<p>《<a href="/2015/06/10/binary-tree-part1/">二叉树与算法第一弹</a>》中主要分析了二叉树的3类算法问题：性质分析（譬如计算最高深度）、遍历问题、构建二叉树。本文将继续以LeetCode为参考，分析二叉树的其他算法问题。</p>
<h2 id="反转二叉树"><strong>反转二叉树</strong></h2>
<p>近期，我们猿族有意见比较吸引人的新闻，HomeBrew的作者Max Howell去Google面试悲剧了，原因是他没能用白板解出一道题，这道题其实就是让反转一棵二叉树，Max Howell的吐槽如下：<br><img style="margin-left:0" src="/img/201506/20150619-01.jpg" width="330" height="190/"></p>
<p>Max Howell是Mac上著名软件HomeBrew的作者，Homebrew是什么？可以理解为Ubuntu上的apt-get，用这个软件可以轻松地装其他的Mac上的软件（主要是服务程序）。对于程序员，HomeBrew是不可或缺的。各大Online Judge合时宜将该题加入了自己的题库，LeetCode也不例外，详见<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="external">Invert Binary Tree</a>。此题非常简单，使用递归四五行代码就能解决：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param {TreeNode} root</span></div><div class="line">    <span class="comment"># @return {TreeNode}</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        left, right = self.invertTree(root.left), self.invertTree(root.right)</div><div class="line">        root.left, root.right = right, left</div><div class="line">        <span class="keyword">return</span> root</div></pre></figure>

<p>我很疑惑能够开发HomeBrew的牛人怎么会解不出这样的题目呢？也许是他没审好题吧，或许他完全搞不明白为什么有这样的题目…</p>
<p>递归处理「二叉树反转」问题实在太简单了，若不采用递归，如何解决呢？</p>
<h2 id="二叉树和其他数据结构"><strong>二叉树和其他数据结构</strong></h2>
<p>LeetCode有一类题非常常见：不同数据结构之间的转换。对于二叉树，LeetCode目前有两道题是让将其他数据结构转换为平衡二叉搜索树：</p>
<ul>
<li>已排序数组转平衡二叉搜索树</li>
<li>已排序链表转平衡二叉搜索树</li>
</ul>
<h3 id="已排序数组转平衡二叉搜索树"><strong>已排序数组转平衡二叉搜索树</strong></h3>
<p>LeetCode有题：<a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="external">Convert Sorted Array to Binary Search Tree</a>。Solution策略比较简单，找到数组的中点（中位数），该点作为根节点，左侧子数组作为左子树，右侧子数组作为右子树，如此递归处理。数组每个元素只处理一遍，时间复杂为O(n)。我的Solution如下：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param {integer[]} nums</span></div><div class="line">    <span class="comment"># @return {TreeNode}</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>, len(nums))</div><div class="line">	</div><div class="line"><span class="comment"># 返回构建的子树root</span></div><div class="line"><span class="comment"># 输入参数：nums是数组，start, stop构成slice，左闭右开，[start,stop)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildBST</span><span class="params">(nums, start, stop)</span>:</span></div><div class="line">    <span class="keyword">if</span> start == stop:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> start == stop-<span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> TreeNode(nums[start])</div><div class="line">    </div><div class="line">    mid = (start+stop) / <span class="number">2</span></div><div class="line">    root = TreeNode(nums[mid])</div><div class="line">    root.left = buildBST(nums, start, mid)</div><div class="line">    root.right = buildBST(nums, mid+<span class="number">1</span>, stop)</div><div class="line">    <span class="keyword">return</span> root</div></pre></figure>

<h3 id="已排序链表转平衡二叉搜索树"><strong>已排序链表转平衡二叉搜索树</strong></h3>
<p>LeetCode有题：<a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="external">Convert Sorted List to Binary Search Tree</a>。解题思路和上一个题目类似，只是数组能够以常数时间定为到中点，链表定为到中位数的时间复杂度却是O(n)。总之，我的Solution如下：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param {ListNode} head</span></div><div class="line">    <span class="comment"># @return {TreeNode}</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="keyword">return</span> buildBST(head)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildBST</span><span class="params">(head)</span>:</span></div><div class="line">    <span class="comment"># 计算链表的长度</span></div><div class="line">    node = head</div><div class="line">    n = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        n, node = n+<span class="number">1</span>, node.next</div><div class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> TreeNode(head.val)</div><div class="line">    </div><div class="line">    <span class="comment"># 找到中间结点，并切割为两个链表</span></div><div class="line">    node = head</div><div class="line">    i = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> i &lt; n/<span class="number">2</span>-<span class="number">1</span>:</div><div class="line">        i += <span class="number">1</span></div><div class="line">        node = node.next</div><div class="line">    mid = node.next</div><div class="line">    node.next = <span class="keyword">None</span></div><div class="line">    </div><div class="line">    <span class="comment"># 递归</span></div><div class="line">    root = TreeNode(mid.val)</div><div class="line">    root.left = buildBST(head)</div><div class="line">    root.right = buildBST(mid.next)</div><div class="line">    <span class="keyword">return</span> root</div></pre></figure>

<h3 id="将平衡二叉树撸成链表"><strong>将平衡二叉树撸成链表</strong></h3>
<p>LeetCode有题：<a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="external">Flatten Binary Tree to Linked List</a>，描述如下：</p>
<blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
</blockquote>
<p>这道题实在太简单了，直接上代码：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param {TreeNode} root</span></div><div class="line">    <span class="comment"># @return {void} Do not return anything, modify root in-place instead.</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></div><div class="line">        fakeRoot = TreeNode(<span class="number">0</span>)</div><div class="line">        leaf = fakeRoot</div><div class="line">        </div><div class="line">        node = root</div><div class="line">        stack = []</div><div class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                stack.append(node.right)</div><div class="line">            leaf.right = node</div><div class="line">            leaf = node</div><div class="line">            node = node.left</div><div class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> len(stack) &gt; <span class="number">0</span>:</div><div class="line">                node = stack.pop()</div><div class="line">            leaf.left = <span class="keyword">None</span></div></pre></figure>

<h2 id="二叉树遍历衍生题"><strong>二叉树遍历衍生题</strong></h2>
<p>《<a href="/2015/06/10/binary-tree-part1/">二叉树与算法第一弹</a>》中已经比较详细介绍了四种基本遍历姿势（pre-order，in-order，post-order，level-order）的迭代实现和递归实现。但除此之外，还有一些其他姿势的遍历，譬如Z字型遍历；还有一些算法题目表面上不属于「遍历问题」，但其本质仍然是遍历问题；无论如何，笔者都将这种本质上仍然属于遍历问题的题目称之为「二叉树遍历衍生问题」，LeetCode以及其他地方有很多这样的题目。</p>
<h3 id="Z字型遍历"><strong>Z字型遍历</strong></h3>
<p>LeetCode有题：<a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="external">Binary Tree Zigzag Level Order Traversal</a>，描述如下：</p>
<blockquote>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
</blockquote>
<p>其本质和「层序遍历」一样，都属于「广度优先搜索」。代码如下：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param {TreeNode} root</span></div><div class="line">    <span class="comment"># @return {integer[][]}</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line"></div><div class="line">        curLevel = [root]</div><div class="line">        levelNum = <span class="number">0</span>        <span class="comment"># level号，从0开始</span></div><div class="line">        ret = []</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> len(curLevel) &gt; <span class="number">0</span>:</div><div class="line">            ret.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> curLevel])</div><div class="line">            nextLevel = []</div><div class="line">            <span class="keyword">if</span> levelNum % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(curLevel))[::-<span class="number">1</span>]:</div><div class="line">                    node = curLevel[i]</div><div class="line">                    <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                        nextLevel.append(node.right)</div><div class="line">                    <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                        nextLevel.append(node.left)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(curLevel))[::-<span class="number">1</span>]:</div><div class="line">                    node = curLevel[i]</div><div class="line">                    <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                        nextLevel.append(node.left)</div><div class="line">                    <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                        nextLevel.append(node.right)</div><div class="line">            curLevel = nextLevel</div><div class="line">            levelNum += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> ret</div></pre></figure>

<h3 id="Sum_Root_to_Leaf_Numbers"><strong>Sum Root to Leaf Numbers</strong></h3>
<p>LeetCode有题：<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="external">Sum Root to Leaf Numbers</a>，描述如下：</p>
<blockquote>
<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.<br>&nbsp;<br>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.<br>&nbsp;<br>Find the total sum of all root-to-leaf numbers.</p>
</blockquote>
<p>这道题本质是一道「深度优先搜索」问题，我采用迭代的方式解决问题，代码如下：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param {TreeNode} root</span></div><div class="line">    <span class="comment"># @return {integer}</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">            </div><div class="line">        ret = <span class="number">0</span></div><div class="line">        stack = []				<span class="comment"># Python数组构建简单的「堆」</span></div><div class="line">        down, up = <span class="number">1</span>, <span class="number">2</span></div><div class="line">        stack.append(root)</div><div class="line">        pre, dir = <span class="keyword">None</span>, down</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</div><div class="line">            cur = stack[-<span class="number">1</span>]</div><div class="line">            <span class="keyword">if</span> dir == down:</div><div class="line">                <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> cur.right <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># cur是叶子结点</span></div><div class="line">                    mul = <span class="number">1</span></div><div class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(stack))[::-<span class="number">1</span>]:    <span class="comment"># stack中的结点构成了从root到leaf的路径</span></div><div class="line">                        ret += (stack[i].val * mul)</div><div class="line">                        mul *= <span class="number">10</span></div><div class="line">                    pre, dir = cur, up</div><div class="line">                    stack.pop()</div><div class="line">                <span class="keyword">elif</span> cur.left <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                    stack.append(cur.right)</div><div class="line">                    pre, dir = cur, down</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stack.append(cur.left)</div><div class="line">                    pre, dir = cur, down</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> pre <span class="keyword">is</span> cur.left <span class="keyword">and</span> cur.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    stack.append(cur.right)</div><div class="line">                    pre, dir = cur, down</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    pre, dir = cur, up</div><div class="line">                    stack.pop()</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> ret</div></pre></figure>

<p>这道题使用递归解决就更简单了，这里就不贴代码了！</p>
<h3 id="Populating_Next_Right_Pointers_in_Each_Node"><strong>Populating Next Right Pointers in Each Node</strong></h3>
<p>LeetCode有题：<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a>，描述如下：</p>
<blockquote>
<p>Given a binary tree<br>&nbsp;&nbsp;&nbsp;&nbsp;struct TreeLinkNode {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeLinkNode <em>left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeLinkNode </em>right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeLinkNode *next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<br>&nbsp;<br>Initially, all next pointers are set to NULL.<br>&nbsp;<br>Note:</p>
<ul>
<li>You may only use constant extra space.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
</blockquote>
<p>显然，这道题是Level遍历的衍生，我的Solution如下：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param root, a tree link node</span></div><div class="line">    <span class="comment"># @return nothing</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        curLevel = [root, <span class="keyword">None</span>]</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> len(curLevel) &gt; <span class="number">1</span>:</div><div class="line">            nextLevel = []</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, len(curLevel)-<span class="number">1</span>):</div><div class="line">                curLevel[i].next = curLevel[i+<span class="number">1</span>]</div><div class="line">                <span class="keyword">if</span> curLevel[i].left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    nextLevel.append(curLevel[i].left)</div><div class="line">                <span class="keyword">if</span> curLevel[i].right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    nextLevel.append(curLevel[i].right)</div><div class="line">            nextLevel.append(<span class="keyword">None</span>)</div><div class="line">            curLevel = nextLevel</div></pre></figure>

<h3 id="Binary_Tree_Right_Side_View"><strong>Binary Tree Right Side View</strong></h3>
<p>LeetCode有题：<a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="external">Binary Tree Right Side View</a>，描述如下：</p>
<blockquote>
<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.<br>&nbsp;<br>For example:<br>Given the following binary tree,<br><img style="margin-left:0" src="/img/201506/20150619-02.png" width="170" height="90"><br>You should return [1, 3, 4].</p>
</blockquote>
<p>这道题本质也是「深度优先搜索」问题，我的Solution代码如下：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param {TreeNode} root</span></div><div class="line">    <span class="comment"># @return {integer[]}</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">            </div><div class="line">        ret = []</div><div class="line">        stack = []</div><div class="line">        </div><div class="line">        down, up = <span class="number">1</span>, <span class="number">2</span></div><div class="line">        stack.append(root)</div><div class="line">        pre, dir = <span class="keyword">None</span>, down</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</div><div class="line">            cur = stack[-<span class="number">1</span>]</div><div class="line">            <span class="keyword">if</span> len(stack) &gt; len(ret):</div><div class="line">                ret.append(cur.val)</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> dir == down:</div><div class="line">                <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> cur.right <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                    stack.pop()</div><div class="line">                    pre, dir = cur, up</div><div class="line">                <span class="keyword">elif</span> cur.right <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                    stack.append(cur.left)</div><div class="line">                    pre, dir = cur, down</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stack.append(cur.right)</div><div class="line">                    pre, dir = cur, down</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> pre <span class="keyword">is</span> cur.right <span class="keyword">and</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    stack.append(cur.left)</div><div class="line">                    pre, dir = cur, down</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stack.pop()</div><div class="line">                    pre, dir = cur, up</div><div class="line">        <span class="keyword">return</span> ret</div></pre></figure>

<h3 id="路径问题"><strong>路径问题</strong></h3>
<p>「路径问题」在常见二叉树算法题中占据相当重要的位置，「二叉树」的路径问题从某种角度上讲也算「二叉树遍历」的衍生问题，但笔者在写博客时觉得还是应该将它独立出来，因为我预感以后在别的地方还会遇到更多更复杂的路径问题。</p>
<p><strong>Path Sum</strong></p>
<p>LeetCode有题：<a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="external">Path Sum</a>，描述如下：</p>
<blockquote>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
</blockquote>
<p>这道题的本质属于「深度优先搜索」，笔者使用迭代策略实现，Solution代码如下：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param root, a tree node</span></div><div class="line">    <span class="comment"># @param sum, an integer</span></div><div class="line">    <span class="comment"># @return a boolean</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        </div><div class="line">        stack = []</div><div class="line">        down, up = <span class="number">1</span>, <span class="number">2</span></div><div class="line">        stack.append(root)</div><div class="line">        sum -= root.val</div><div class="line">        pre, dir = <span class="keyword">None</span>, down</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</div><div class="line">            cur = stack[-<span class="number">1</span>]</div><div class="line">            <span class="keyword">if</span> dir == down:</div><div class="line">                <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> cur.right <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># 叶子结点</span></div><div class="line">                    <span class="keyword">if</span> sum == <span class="number">0</span>:</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">                    stack.pop()</div><div class="line">                    sum += cur.val</div><div class="line">                    pre, dir = cur, up</div><div class="line">                <span class="keyword">elif</span> cur.left <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                    stack.append(cur.right)</div><div class="line">                    sum -= cur.right.val</div><div class="line">                    pre, dir = cur, down</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stack.append(cur.left)</div><div class="line">                    sum -= cur.left.val</div><div class="line">                    pre, dir = cur, down</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> pre <span class="keyword">is</span> cur.left <span class="keyword">and</span> cur.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    stack.append(cur.right)</div><div class="line">                    sum -= cur.right.val</div><div class="line">                    pre, dir = cur, down</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stack.pop()</div><div class="line">                    sum += cur.val</div><div class="line">                    pre, dir = cur, up</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></figure>

<p><strong>Path Sum II</strong></p>
<p><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="external">Path Sum</a>只是判断是否存在一条路径满足给定要求，<a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="external">Path Sum II</a>更进一步，要求将所有满足条件的结点给汇总出来，描述如下：</p>
<blockquote>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
</blockquote>
<p>处理策略类似，我的Solution代码如下：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param {TreeNode} root</span></div><div class="line">    <span class="comment"># @param {integer} sum</span></div><div class="line">    <span class="comment"># @return {integer[][]}</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">	</div><div class="line">        down, up = <span class="number">1</span>, <span class="number">2</span></div><div class="line">        stack = [root]</div><div class="line">        sum -= root.val</div><div class="line">        per, dir = <span class="keyword">None</span>, down</div><div class="line">        ret = []</div><div class="line">	</div><div class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</div><div class="line">            cur = stack[-<span class="number">1</span>]     <span class="comment"># stack.top()</span></div><div class="line">            <span class="keyword">if</span> dir == down:</div><div class="line">                <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> cur.right <span class="keyword">is</span> <span class="keyword">None</span>:      <span class="comment"># 叶子结点</span></div><div class="line">                    <span class="keyword">if</span> sum == <span class="number">0</span>:	<span class="comment"># 略有不同</span></div><div class="line">                        ret.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> stack])</div><div class="line">                    stack.pop()</div><div class="line">                    sum += cur.val</div><div class="line">                    pre, dir = cur, up</div><div class="line">                <span class="keyword">elif</span> cur.left <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                    stack.append(cur.right)</div><div class="line">                    sum -= cur.right.val</div><div class="line">                    pre, dir = cur, down</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stack.append(cur.left)</div><div class="line">                    sum -= cur.left.val</div><div class="line">                    pre, dir = cur, down</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> pre <span class="keyword">is</span> cur.left <span class="keyword">and</span> cur.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    stack.append(cur.right)</div><div class="line">                    sum -= cur.right.val</div><div class="line">                    pre, dir = cur, down</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stack.pop()</div><div class="line">                    sum += cur.val</div><div class="line">                    pre, dir = cur, up</div><div class="line">        <span class="keyword">return</span> ret</div></pre></figure>

<p><strong>Binary Tree Maximum Path Sum</strong></p>
<p>LeetCode有题：<a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="external">Binary Tree Maximum Path Sum</a>，描述如下：</p>
<blockquote>
<p>Given a binary tree, find the maximum path sum.<br>&nbsp;<br>The path may start and end at any node in the tree.<br>&nbsp;<br>For example:<br>Given the below binary tree,<br><img style="margin-left:0" src="/img/201506/20150619-03.png" width="46" height="52"><br>Return 6.</p>
</blockquote>
<p>我的Solution代码如下：</p>
<figure class="highlight Python"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param {TreeNode} root</span></div><div class="line">    <span class="comment"># @return {integer}</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        results = [root.val]</div><div class="line">        _ = maxPath(root, results)</div><div class="line">        <span class="keyword">return</span> results[<span class="number">0</span>]</div><div class="line">	</div><div class="line"><span class="comment"># A存放已有最大值</span></div><div class="line"><span class="comment"># root is not None</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPath</span><span class="params">(root, results)</span>:</span></div><div class="line">    r1, r2 = <span class="number">0</span>, <span class="number">0</span></div><div class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        r1 = maxPath(root.left, results)</div><div class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        r2 = maxPath(root.right, results)</div><div class="line">    <span class="keyword">if</span> r1 &lt; <span class="number">0</span>:</div><div class="line">        r1 = <span class="number">0</span></div><div class="line">    <span class="keyword">if</span> r2 &lt; <span class="number">0</span>:</div><div class="line">        r2 = <span class="number">0</span></div><div class="line">    </div><div class="line">    temp = r1 + root.val + r2</div><div class="line">    <span class="keyword">if</span> temp &gt; results[<span class="number">0</span>]:</div><div class="line">        results[<span class="number">0</span>] = temp</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> root.val + max(r1, r2)</div></pre></figure>

<h2 id="其他问题"><strong>其他问题</strong></h2>
<p><strong>Recover Binary Search Tree</strong></p>
<p>LeetCode有题<a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="external">Recover Binary Search Tree</a>，描述如下：</p>
<blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.<br>&nbsp;<br>Recover the tree without changing its structure.<br>&nbsp;<br>Note:<br>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
</blockquote>
<p>此题比较难，还没思路，尚未解答，留个坑吧，日后填上！</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/LeetCode/">LeetCode</a><a href="/tags/Binary-Tree/">Binary Tree</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://sadjason.github.io/2015/06/12/binary-tree-part2/" data-title="二叉树与算法 第二弹 | 张不坏的博客" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/06/16/UIWebView-loading-local-html/" title="UIWebView加载本地HTML文件">
  <strong>PREVIOUS:</strong><br/>
  <span>
  UIWebView加载本地HTML文件</span>
</a>
</div>


<div class="next">
<a href="/2015/06/10/binary-tree-part1/"  title="二叉树与算法 第一弹">
 <strong>NEXT:</strong><br/> 
 <span>二叉树与算法 第一弹
</span>
</a>
</div>

</nav>

		<!-- 多说评论框 start -->
	<!--<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>-->
	<div class="ds-thread" data-thread-key="2015/06/12/binary-tree-part2/" data-title="二叉树与算法 第二弹" data-url=""></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
		var duoshuoQuery = {short_name:"张不坏"};
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
	</script>
	<!-- 多说公共JS代码 end -->

</div>  
      
  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反转二叉树"><span class="toc-number">2.</span> <span class="toc-text">反转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树和其他数据结构"><span class="toc-number">3.</span> <span class="toc-text">二叉树和其他数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#已排序数组转平衡二叉搜索树"><span class="toc-number">3.1.</span> <span class="toc-text">已排序数组转平衡二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#已排序链表转平衡二叉搜索树"><span class="toc-number">3.2.</span> <span class="toc-text">已排序链表转平衡二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将平衡二叉树撸成链表"><span class="toc-number">3.3.</span> <span class="toc-text">将平衡二叉树撸成链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树遍历衍生题"><span class="toc-number">4.</span> <span class="toc-text">二叉树遍历衍生题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Z字型遍历"><span class="toc-number">4.1.</span> <span class="toc-text">Z字型遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sum_Root_to_Leaf_Numbers"><span class="toc-number">4.2.</span> <span class="toc-text">Sum Root to Leaf Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Populating_Next_Right_Pointers_in_Each_Node"><span class="toc-number">4.3.</span> <span class="toc-text">Populating Next Right Pointers in Each Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary_Tree_Right_Side_View"><span class="toc-number">4.4.</span> <span class="toc-text">Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路径问题"><span class="toc-number">4.5.</span> <span class="toc-text">路径问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他问题"><span class="toc-number">5.</span> <span class="toc-text">其他问题</span></a></li></ol>
  </div>

<div id="asidepart">
<div id="authorInfo">
	
		<div class="author-logo"></div>		
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
	</div>
</div>
<aside class="clearfix">


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>31</sup></a></li>
		
			<li><a href="/categories/Nodejs/" title="Node.js">Node.js<sup>1</sup></a></li>
		
			<li><a href="/categories/Objective-C/" title="Objective-C">Objective-C<sup>10</sup></a></li>
		
			<li><a href="/categories/Others/" title="Others">Others<sup>1</sup></a></li>
		
			<li><a href="/categories/Python/" title="Python">Python<sup>5</sup></a></li>
		
			<li><a href="/categories/Swift/" title="Swift">Swift<sup>17</sup></a></li>
		
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>63</sup></a></li>
		
		</ul>
</div>


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07">七月 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06">六月 2015</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05">五月 2015</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04">四月 2015</a><span class="archive-list-count">33</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03">三月 2015</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02">二月 2015</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01">一月 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08">八月 2014</a><span class="archive-list-count">8</span></li></ul>
  </div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/AFNetworking/" title="AFNetworking">AFNetworking<sup>5</sup></a></li>
		
			<li><a href="/tags/Array/" title="Array">Array<sup>7</sup></a></li>
		
			<li><a href="/tags/Assets/" title="Assets">Assets<sup>1</sup></a></li>
		
			<li><a href="/tags/Auto-Layout/" title="Auto Layout">Auto Layout<sup>1</sup></a></li>
		
			<li><a href="/tags/Backtracking/" title="Backtracking">Backtracking<sup>3</sup></a></li>
		
			<li><a href="/tags/Binary-Tree/" title="Binary Tree">Binary Tree<sup>2</sup></a></li>
		
			<li><a href="/tags/Block/" title="Block">Block<sup>1</sup></a></li>
		
			<li><a href="/tags/Debug/" title="Debug">Debug<sup>1</sup></a></li>
		
			<li><a href="/tags/Dynamic-Programming/" title="Dynamic Programming">Dynamic Programming<sup>8</sup></a></li>
		
			<li><a href="/tags/Edit-Distance/" title="Edit Distance">Edit Distance<sup>1</sup></a></li>
		
			<li><a href="/tags/GCD/" title="GCD">GCD<sup>9</sup></a></li>
		
			<li><a href="/tags/Greedy/" title="Greedy">Greedy<sup>1</sup></a></li>
		
			<li><a href="/tags/HTTP/" title="HTTP">HTTP<sup>1</sup></a></li>
		
			<li><a href="/tags/KMP/" title="KMP">KMP<sup>1</sup></a></li>
		
			<li><a href="/tags/KVO/" title="KVO">KVO<sup>1</sup></a></li>
		
			<li><a href="/tags/LeetCode/" title="LeetCode">LeetCode<sup>26</sup></a></li>
		
			<li><a href="/tags/Linked-List/" title="Linked List">Linked List<sup>1</sup></a></li>
		
			<li><a href="/tags/Mantle/" title="Mantle">Mantle<sup>1</sup></a></li>
		
			<li><a href="/tags/Masonry/" title="Masonry">Masonry<sup>1</sup></a></li>
		
			<li><a href="/tags/NSError/" title="NSError">NSError<sup>1</sup></a></li>
		
			<li><a href="/tags/NSOperation/" title="NSOperation">NSOperation<sup>1</sup></a></li>
		
			<li><a href="/tags/Nodejs/" title="Node.js">Node.js<sup>1</sup></a></li>
		
			<li><a href="/tags/Reachability/" title="Reachability">Reachability<sup>1</sup></a></li>
		
			<li><a href="/tags/RunLoop/" title="RunLoop">RunLoop<sup>1</sup></a></li>
		
			<li><a href="/tags/Runtime/" title="Runtime">Runtime<sup>5</sup></a></li>
		
			<li><a href="/tags/SVPullToRefresh/" title="SVPullToRefresh">SVPullToRefresh<sup>1</sup></a></li>
		
			<li><a href="/tags/Sort/" title="Sort">Sort<sup>9</sup></a></li>
		
			<li><a href="/tags/String/" title="String">String<sup>9</sup></a></li>
		
			<li><a href="/tags/Testing/" title="Testing">Testing<sup>1</sup></a></li>
		
			<li><a href="/tags/Tree/" title="Tree">Tree<sup>1</sup></a></li>
		
			<li><a href="/tags/Two-Pointers/" title="Two Pointers">Two Pointers<sup>1</sup></a></li>
		
			<li><a href="/tags/UIWebView/" title="UIWebView">UIWebView<sup>1</sup></a></li>
		
			<li><a href="/tags/WebViewJavascriptBridge/" title="WebViewJavascriptBridge">WebViewJavascriptBridge<sup>1</sup></a></li>
		
			<li><a href="/tags/Xcode/" title="Xcode">Xcode<sup>2</sup></a></li>
		
			<li><a href="/tags/ZBar/" title="ZBar">ZBar<sup>1</sup></a></li>
		
			<li><a href="/tags/iOS/" title="iOS">iOS<sup>6</sup></a></li>
		
			<li><a href="/tags/iPhone/" title="iPhone">iPhone<sup>1</sup></a></li>
		
			<li><a href="/tags/property/" title="property">property<sup>1</sup></a></li>
		
			<li><a href="/tags/socket-io/" title="socket-io">socket-io<sup>1</sup></a></li>
		
			<li><a href="/tags/多线程/" title="多线程">多线程<sup>3</sup></a></li>
		
			<li><a href="/tags/常用/" title="常用">常用<sup>9</sup></a></li>
		
		</ul>
</div>



</aside>
</div>
    </div>
    <footer><div id="footer" >

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  //back to top
  function backToTop(){
    var buttonHTML = $("<a href=\"#top\" id=\"back-top\">" + "<span>Back to Top</span></a>");
    buttonHTML.appendTo($("body"));
    var buttonToTop = $("#back-top");
    // hide #back-top first
    buttonToTop.hide();

    // fade in #back-top
    $(function() {
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                buttonToTop.fadeIn();
            } else {
                buttonToTop.fadeOut();
            }
        });
        // scroll body to 0px on click
        buttonToTop.click(function() {
            $('body,html').animate({
                scrollTop: 0
            }, 800);
            return false;
        });
    });
  }
  backToTop();

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      ta = $('#toc.toc-aside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });

  var show = true;
  c.click(function(){
    if(show == true){
        a.addClass('fadeOut').css('display', 'none');
        ta.css('display', 'block').addClass('fadeIn');
        m.addClass('moveMain');  
    }else{
        a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');     
        ta.css('display', 'none'); 
        m.removeClass('moveMain');
        $('#toc.toc-aside').css('display', 'none');
    }
    show = !show;
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{

    $(window).scroll(function(){
      ta.css("top",Math.max(140,240-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"null"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
